(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{449:function(t,s,a){"use strict";a.r(s);var n=a(2),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"强一致性更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强一致性更新"}},[t._v("#")]),t._v(" 强一致性更新")]),t._v(" "),s("p",[t._v("对于经常访问的数据，通常会选择缓存到内存中以加快读取速度。在实际编码过程中，可能会有以下编码")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" lock "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" redisTemplate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("opsForValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lockKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StringUtils")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNotEmpty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doUpdateDB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doUpdateCache")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("这里不去考虑doUpdateCache()是如何实现的，即并不在意使用的是本地缓存还是分布式缓存。\n这里讨论的是在更新DB的时候，将缓存的数据也更新的编码方式。")]),t._v(" "),s("p",[t._v("更新DB的时候，更新缓存，并且使用到了分布式锁，目的是为了保持DB和缓存数据的一致性。而且这种方式是强一致性，并不是为了保持最终一致性。\n强一致性：写入后，后续读取操作都将返回该写入的值或者更新的值。不存在不一致的时期。\n最终一致性：写入后，存在一个窗口期，在此期间可能会返回不一致的数据。")]),t._v(" "),s("p",[t._v("数据一致性本身是分布式服务中一个重要概念，实际中应该根据不同的业务需求，选择不同的数据一致性方法。")]),t._v(" "),s("p",[t._v("上述这种缓存更新方式，就可以保证数据的强一致性。")]),t._v(" "),s("h3",{attrs:{id:"最终一致性更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最终一致性更新"}},[t._v("#")]),t._v(" 最终一致性更新")]),t._v(" "),s("p",[t._v("有的时候，缓存的数据可以延迟一点时间，这个时候可以考虑使用最终一致性方式。大概介绍一下实现原理。\n（1）缓存的数据来源于DB，通过继承DB的拦截器Interceptor接口，对于指定的Table进行监听，一旦有Insert、Update、Delete等操作，可以写入一个消息到消息中间件。例如：kafka、redis。注意为了确保最终一致性，建议使用kafka这种可靠的消息模型，对于redis的键空间监听的PUB/SUB模式而言，有可能发生消息的丢失。\n（2）消费消息，并从DB中更新缓存\n具体的实现方式等有时间编写对应demo，这里还可以参考一下spring cloud Stream实现消息的最终一致性。")]),t._v(" "),s("h3",{attrs:{id:"数据一致性优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据一致性优缺点"}},[t._v("#")]),t._v(" 数据一致性优缺点")]),t._v(" "),s("p",[t._v("（1）强一致性\n优点：")]),t._v(" "),s("ul",[s("li",[t._v("数据可预测性：应用程序和最终用户可以信赖这样一个事实：一旦数据被写入并确认，它就可以在系统的所有部分以该状态立即可用。这种可预测性简化了应用程序设计的许多方面。")]),t._v(" "),s("li",[t._v("更简单的应用程序逻辑：鉴于数据的可预测性，应用程序逻辑不必考虑临时的不一致。这通常会导致代码更干净、更简单。")]),t._v(" "),s("li",[t._v("无需解决冲突：由于每个写入操作都会立即在系统中传播并得到确认，因此不存在冲突写入的空间\n缺点：")]),t._v(" "),s("li",[t._v("可用性降低的可能性：实现强一致性通常需要系统中的大多数或所有节点就写入达成一致。如果某些节点不可用，系统可能无法处理写入请求，从而导致可用性降低。")]),t._v(" "),s("li",[t._v("更高的延迟：确保所有节点或副本都同意写入操作可能会导致延迟，尤其是在数据传播可能需要花费大量时间的地理分布式系统中。")]),t._v(" "),s("li",[t._v("可扩展性挑战：随着系统的增长，确保越来越多的节点之间的即时一致性可能变得具有挑战性。它可能需要复杂的同步机制，从而导致复杂性增加。")])]),t._v(" "),s("p",[t._v("（2）最终一致性\n优点：")]),t._v(" "),s("ul",[s("li",[t._v("高可用性：鉴于所有节点或副本不必在写入后立即达成一致，即使系统的某些部分暂时无法访问，系统仍然可以运行并响应请求。这对于面向全球的系统尤其重要，因为区域中断不应中断整个服务。")]),t._v(" "),s("li",[t._v("更好的性能：由于每次写入操作后不需要立即同步所有节点的数据，因此系统可以更快地响应写入请求。对于速度至关重要的系统来说，减少延迟至关重要。")]),t._v(" "),s("li",[t._v("增强的可扩展性：横向扩展、添加更多节点来处理增加的负载的系统可以从最终一致性中受益。添加节点后，无需立即将它们与现有数据同步，从而使扩展过程更加顺畅。")])]),t._v(" "),s("p",[t._v("缺点：")]),t._v(" "),s("ul",[s("li",[t._v("临时数据不一致：存在一个时间窗口，在此期间系统的不同部分可能会返回不同的数据视图。这种不一致可能会导致混乱或错误的决策，特别是在数据准确性（即使是短时间内）至关重要的系统中。")]),t._v(" "),s("li",[t._v("应用程序逻辑的复杂性增加：开发人员通常必须考虑应用程序逻辑中潜在的不一致。这可能涉及实施补偿事务、重试或其他机制来处理临时数据不一致。")]),t._v(" "),s("li",[t._v("潜在的冲突：如果两个操作同时发生在不同的节点上，则可能会发生冲突。解决这些冲突，尤其是以自动化方式，可能具有挑战性。")])]),t._v(" "),s("p",[t._v("虽然最终一致性提供了高可用性、改进的性能和可扩展性的好处，但它是以临时数据不一致和潜在冲突为代价的。另一方面，强一致性提供了数据可预测性和简化的应用程序逻辑的奢华，但可能带来与可用性、延迟和可扩展性相关的挑战。")]),t._v(" "),s("p",[t._v("在这些模型之间做出明智的选择需要深入了解系统的需求、用户期望和可接受的权衡。")])])}),[],!1,null,null,null);s.default=e.exports}}]);